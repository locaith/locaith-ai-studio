-- 1. Enable UUID extension
create extension if not exists "uuid-ossp";

-- 2. Create profiles table (if it doesn't exist)
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  full_name text,
  avatar_url text,
  role text default 'user',
  status text default 'offline',
  last_seen timestamp with time zone default now(),
  updated_at timestamp with time zone
);

-- Enable RLS on profiles
alter table public.profiles enable row level security;

-- Policies for profiles
create policy "Public profiles are viewable by everyone." on public.profiles
  for select using (true);

create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

create policy "Users can update own profile." on public.profiles
  for update using (auth.uid() = id);

-- 3. Create a trigger to auto-create profile on signup
-- This ensures that whenever a user signs up via email or OAuth, a profile is created
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (
    new.id,
    new.email,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
end;
$$ language plpgsql security definer;

-- Drop trigger if exists to ensure clean slate for updates
drop trigger if exists on_auth_user_created on auth.users;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 4. Create contacts table
create table if not exists public.contacts (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) not null,
  contact_id uuid references public.profiles(id) not null,
  created_at timestamp with time zone default now(),
  unique(user_id, contact_id),
  is_pinned boolean default false,
  muted_until bigint default 0
);

-- Ensure columns exist (migration for existing tables)
alter table public.contacts add column if not exists is_pinned boolean default false;
alter table public.contacts add column if not exists muted_until bigint default 0;

alter table public.contacts enable row level security;

-- Policies for contacts
create policy "Users can view their own contacts." on public.contacts
  for select using (auth.uid() = user_id);

create policy "Users can add contacts." on public.contacts
  for insert with check (auth.uid() = user_id);

create policy "Users can update their own contacts." on public.contacts
  for update using (auth.uid() = user_id);

-- 5. Create messages table
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  sender_id uuid references public.profiles(id) not null,
  receiver_id uuid references public.profiles(id), -- Nullable for group messages
  group_id uuid, -- For group messages
  content text,
  type text default 'text', -- 'text', 'image', 'file', 'link', 'sticker', 'contact'
  file_url text,
  priority text default 'normal', -- 'normal', 'important', 'urgent'
  created_at timestamp with time zone default now() not null,
  is_read boolean default false
);

alter table public.messages enable row level security;

-- Policies for messages
-- Drop existing policy if exists to update logic
drop policy if exists "Users can see their own messages." on public.messages;
drop policy if exists "Users can send messages." on public.messages;

create policy "Users can see their own messages and group messages." on public.messages
  for select using (
    auth.uid() = sender_id 
    or auth.uid() = receiver_id 
    or (
      group_id is not null and exists (
        select 1 from public.group_members 
        where group_id = messages.group_id and user_id = auth.uid()
      )
    )
  );

create policy "Users can send messages." on public.messages
  for insert with check (auth.uid() = sender_id);

-- 6. Create appointments table (Updated for shared functionality)
create table if not exists public.appointments (
  id uuid default uuid_generate_v4() primary key,
  title text not null,
  time timestamp with time zone not null,
  created_by uuid references public.profiles(id) not null,
  created_at timestamp with time zone default now(),
  contact_id uuid references public.profiles(id), -- Nullable for group appointments
  group_id uuid, -- Nullable for 1-on-1 appointments
  repeat_pattern text default 'none' -- 'none', 'daily', 'weekly', 'monthly'
);

-- Ensure columns exist (migration)
alter table public.appointments add column if not exists group_id uuid;
alter table public.appointments add column if not exists repeat_pattern text default 'none';

alter table public.appointments enable row level security;

-- Policies for appointments (Shared Visibility)
drop policy if exists "Users can view their own appointments." on public.appointments;
drop policy if exists "Users can create appointments." on public.appointments;
drop policy if exists "Users can delete their own appointments." on public.appointments;

-- View Policy: Users can view appointments they created OR where they are the contact OR part of the group
create policy "Users can view shared appointments." on public.appointments
  for select using (
    auth.uid() = created_by 
    or auth.uid() = contact_id
    or (
      group_id is not null and exists (
        select 1 from public.group_members 
        where group_id = appointments.group_id and user_id = auth.uid()
      )
    )
  );

-- Create Policy: Users can create appointments
create policy "Users can create appointments." on public.appointments
  for insert with check (auth.uid() = created_by);

-- Delete Policy: Users can delete appointments they created
create policy "Users can delete their own appointments." on public.appointments
  for delete using (auth.uid() = created_by);


-- 7. Group Chat Support

-- Create groups table
create table if not exists public.groups (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  avatar_url text,
  created_by uuid references public.profiles(id),
  created_at timestamp with time zone default now()
);

alter table public.groups enable row level security;

-- Policies for groups
create policy "Users can view groups they are members of." on public.groups
  for select using (
    exists (
      select 1 from public.group_members
      where group_id = groups.id and user_id = auth.uid()
    )
  );

create policy "Users can create groups." on public.groups
  for insert with check (auth.uid() = created_by);

-- Create group_members table
create table if not exists public.group_members (
  id bigint generated by default as identity primary key,
  group_id uuid references public.groups(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null,
  role text default 'member', -- 'admin', 'member'
  joined_at timestamp with time zone default now(),
  unique(group_id, user_id)
);

alter table public.group_members enable row level security;

-- Policies for group_members
create policy "Users can view members of their groups." on public.group_members
  for select using (
    exists (
      select 1 from public.group_members gm
      where gm.group_id = group_members.group_id and gm.user_id = auth.uid()
    )
  );

create policy "Users can add members to their groups." on public.group_members
  for insert with check (
    exists (
      select 1 from public.group_members gm
      where gm.group_id = group_members.group_id 
      and gm.user_id = auth.uid() 
      and gm.role = 'admin'
    )
    or
    -- Allow creator to add themselves/others initially (simplified)
    auth.uid() = user_id -- Allow users to add themselves (if we want invite links later) or check group creator logic in app
  );
-- Note: Simplified insert policy. In production, check group.created_by or admin role strictly.
-- For now, let's allow insert if the user is inserting themselves or if they are admin.
-- Actually, the initial creation inserts the creator. 
create policy "Admins or Creators can add members." on public.group_members
  for insert with check (true); -- Simplified for prototype to allow creating group + members

-- 8. Friend Requests & Mutual Friends

create table if not exists public.friend_requests (
  id bigint generated by default as identity primary key,
  sender_id uuid references public.profiles(id) not null,
  receiver_id uuid references public.profiles(id) not null,
  status text default 'pending', -- 'pending', 'accepted', 'rejected'
  created_at timestamp with time zone default now(),
  unique(sender_id, receiver_id)
);

alter table public.friend_requests enable row level security;

-- Policies
drop policy if exists "Users can view requests sent or received." on public.friend_requests;
create policy "Users can view requests sent or received." on public.friend_requests
  for select using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "Users can create requests." on public.friend_requests;
create policy "Users can create requests." on public.friend_requests
  for insert with check (auth.uid() = sender_id);

drop policy if exists "Users can update requests received." on public.friend_requests;
create policy "Users can update requests received." on public.friend_requests
  for update using (auth.uid() = receiver_id);

drop policy if exists "Users can delete requests sent." on public.friend_requests;
create policy "Users can delete requests sent." on public.friend_requests
  for delete using (auth.uid() = sender_id);

-- Function to accept request
create or replace function public.accept_friend_request(request_id bigint)
returns void as $$
declare
  req record;
begin
  -- Get request info
  select * into req from public.friend_requests where id = request_id;
  
  -- Verify receiver is current user and status is pending
  if req.receiver_id = auth.uid() and req.status = 'pending' then
    -- 1. Update request status
    update public.friend_requests set status = 'accepted' where id = request_id;
    
    -- 2. Add mutual friends
    insert into public.contacts (user_id, contact_id) values (req.sender_id, req.receiver_id) on conflict do nothing;
    insert into public.contacts (user_id, contact_id) values (req.receiver_id, req.sender_id) on conflict do nothing;
  else
    raise exception 'Invalid request or permission denied';
  end if;
end;
$$ language plpgsql security definer;

-- 9. Create message_reactions table
create table if not exists public.message_reactions (
  id bigint generated by default as identity primary key,
  message_id bigint references public.messages(id) on delete cascade not null,
  user_id uuid references public.profiles(id) not null,
  emoji text not null,
  created_at timestamp with time zone default now() not null,
  unique(message_id, user_id, emoji)
);

alter table public.message_reactions enable row level security;

-- Policies for message_reactions
create policy "Users can see reactions for messages they can see." on public.message_reactions
  for select using (
    exists (
      select 1 from public.messages
      where id = message_reactions.message_id
      and (
        sender_id = auth.uid() 
        or receiver_id = auth.uid()
        or (group_id is not null and exists (select 1 from public.group_members where group_id = messages.group_id and user_id = auth.uid()))
      )
    )
  );

create policy "Users can add their own reactions." on public.message_reactions
  for insert with check (auth.uid() = user_id);

create policy "Users can remove their own reactions." on public.message_reactions
  for delete using (auth.uid() = user_id);

-- Add to Realtime
alter publication supabase_realtime add table public.profiles;
alter publication supabase_realtime add table public.messages;
alter publication supabase_realtime add table public.contacts;
alter publication supabase_realtime add table public.appointments;
alter publication supabase_realtime add table public.groups;
alter publication supabase_realtime add table public.group_members;
alter publication supabase_realtime add table public.friend_requests;
alter publication supabase_realtime add table public.message_reactions;
