-- FIX CHAT V7 (FINAL CLEANUP & REBUILD)
-- Mục tiêu: Xử lý lỗi "operator does not exist: uuid = bigint" bằng cách tắt RLS và xóa sạch Policy gây lỗi trước khi sửa bảng.
-- Hướng dẫn: Copy toàn bộ và chạy trong Supabase SQL Editor.

BEGIN;

-- 1. Vô hiệu hóa RLS (Quan trọng: Để chặn các Policy lỗi không được kích hoạt)
ALTER TABLE IF EXISTS public.messages DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.appointments DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.groups DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.group_members DISABLE ROW LEVEL SECURITY;

-- 2. Xóa các Policy cụ thể có thể gây lỗi Type Mismatch
DROP POLICY IF EXISTS "Users can see their own messages and group messages." ON public.messages;
DROP POLICY IF EXISTS "Users can view shared appointments." ON public.appointments;

-- 3. Xóa hàm helper (CASCADE sẽ tự động xóa các Policy phụ thuộc còn lại)
DROP FUNCTION IF EXISTS public.is_member_of_group(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.is_member_of_group(bigint) CASCADE;
DROP FUNCTION IF EXISTS public.is_group_member(uuid) CASCADE; 
DROP FUNCTION IF EXISTS public.is_group_member(bigint) CASCADE;

-- 4. Loại bỏ cột group_id cũ (nguyên nhân tiềm ẩn của lỗi bigint)
ALTER TABLE public.messages DROP COLUMN IF EXISTS group_id;
ALTER TABLE public.appointments DROP COLUMN IF EXISTS group_id;

-- 5. Xóa bảng Groups và Members (Làm sạch hoàn toàn)
DROP TABLE IF EXISTS public.group_members CASCADE;
DROP TABLE IF EXISTS public.groups CASCADE;

-- 6. TẠO LẠI BẢNG GROUPS (Chuẩn UUID)
CREATE TABLE public.groups (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name TEXT NOT NULL,
  avatar_url TEXT,
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 7. TẠO LẠI BẢNG GROUP_MEMBERS (Chuẩn UUID)
CREATE TABLE public.group_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  role TEXT DEFAULT 'member', -- 'admin', 'member'
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_read_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(group_id, user_id)
);

-- 8. Thêm lại cột group_id cho Messages và Appointments (Chuẩn UUID)
ALTER TABLE public.messages 
ADD COLUMN group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE;

ALTER TABLE public.appointments 
ADD COLUMN group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE;

-- 9. Bật lại RLS
ALTER TABLE public.groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.group_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.appointments ENABLE ROW LEVEL SECURITY;

-- 10. Tạo lại hàm helper (SECURITY DEFINER, Cast rõ ràng)
CREATE OR REPLACE FUNCTION public.is_member_of_group(_group_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 
    FROM public.group_members 
    WHERE group_id = _group_id 
    AND user_id = auth.uid()
  );
END;
$$;
GRANT EXECUTE ON FUNCTION public.is_member_of_group(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_member_of_group(uuid) TO service_role;

-- 11. Thiết lập Policies Mới (Chuẩn UUID)

-- === GROUPS ===
CREATE POLICY "groups_insert_policy" ON public.groups FOR INSERT
WITH CHECK (auth.uid() = created_by); 

CREATE POLICY "groups_select_policy" ON public.groups FOR SELECT
USING (
    created_by = auth.uid() 
    OR 
    EXISTS (SELECT 1 FROM public.group_members WHERE group_id = id AND user_id = auth.uid())
);

CREATE POLICY "groups_update_policy" ON public.groups FOR UPDATE
USING (
    created_by = auth.uid() 
    OR 
    EXISTS (SELECT 1 FROM public.group_members WHERE group_id = id AND user_id = auth.uid() AND role = 'admin')
);

CREATE POLICY "groups_delete_policy" ON public.groups FOR DELETE
USING (auth.uid() = created_by);

-- === GROUP MEMBERS ===
CREATE POLICY "members_select_policy" ON public.group_members FOR SELECT
USING (
    user_id = auth.uid()
    OR
    EXISTS (
        SELECT 1 FROM public.group_members gm 
        WHERE gm.group_id = group_members.group_id AND gm.user_id = auth.uid()
    )
    OR
    EXISTS (
        SELECT 1 FROM public.groups g
        WHERE g.id = group_members.group_id AND g.created_by = auth.uid()
    )
);

CREATE POLICY "members_insert_policy" ON public.group_members FOR INSERT
WITH CHECK (
    user_id = auth.uid()
    OR
    EXISTS (
        SELECT 1 FROM public.groups 
        WHERE id = group_id AND created_by = auth.uid()
    )
    OR
    EXISTS (
        SELECT 1 FROM public.group_members 
        WHERE group_id = group_members.group_id 
        AND user_id = auth.uid() 
        AND role = 'admin'
    )
);

CREATE POLICY "members_delete_policy" ON public.group_members FOR DELETE
USING (
    user_id = auth.uid()
    OR
    EXISTS (
        SELECT 1 FROM public.groups 
        WHERE id = group_id AND created_by = auth.uid()
    )
    OR
    EXISTS (
        SELECT 1 FROM public.group_members 
        WHERE group_id = group_members.group_id 
        AND user_id = auth.uid() 
        AND role = 'admin'
    )
);

-- === MESSAGES ===
-- Tạo lại Policy cho Messages
CREATE POLICY "Users can see their own messages and group messages." ON public.messages
  FOR SELECT USING (
    auth.uid() = sender_id 
    OR auth.uid() = receiver_id 
    OR (
      group_id IS NOT NULL AND public.is_member_of_group(group_id)
    )
  );

-- === APPOINTMENTS ===
-- Tạo lại Policy cho Appointments
CREATE POLICY "Users can view shared appointments." ON public.appointments
  FOR SELECT USING (
    auth.uid() = created_by 
    OR auth.uid() = contact_id
    OR (
      group_id IS NOT NULL AND public.is_member_of_group(group_id)
    )
  );

COMMIT;

NOTIFY pgrst, 'reload schema';
