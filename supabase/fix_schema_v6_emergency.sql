-- FIX SCHEMA V6 (EMERGENCY CLEANUP)
-- Mục tiêu: Khắc phục lỗi "operator does not exist: uuid = bigint" chặn không cho chạy script.
-- Nguyên nhân: Policy đang hoạt động trên bảng có kiểu dữ liệu sai lệch (ví dụ user_id là bigint trong khi auth.uid() là uuid).
-- Giải pháp: Tắt RLS trước -> Xóa bảng -> Tạo lại chuẩn.

BEGIN;

-- 1. Vô hiệu hóa RLS ngay lập tức để tránh lỗi Policy khi thao tác
ALTER TABLE IF EXISTS public.groups DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.group_members DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.messages DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.appointments DISABLE ROW LEVEL SECURITY;

-- 2. Xóa các hàm phụ thuộc (CASCADE)
DROP FUNCTION IF EXISTS public.is_member_of_group(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.is_member_of_group(bigint) CASCADE;
DROP FUNCTION IF EXISTS public.is_group_member(uuid) CASCADE; -- Xóa cả hàm tên cũ nếu có

-- 3. Ngắt liên kết từ bảng messages và appointments
ALTER TABLE public.messages DROP COLUMN IF EXISTS group_id;
ALTER TABLE public.appointments DROP COLUMN IF EXISTS group_id;

-- 4. Xóa bảng (CASCADE)
DROP TABLE IF EXISTS public.group_members CASCADE;
DROP TABLE IF EXISTS public.groups CASCADE;

-- 5. TẠO LẠI BẢNG GROUPS (Chuẩn UUID)
CREATE TABLE public.groups (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name TEXT NOT NULL,
  avatar_url TEXT,
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 6. TẠO LẠI BẢNG GROUP_MEMBERS (Chuẩn UUID)
CREATE TABLE public.group_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  role TEXT DEFAULT 'member', -- 'admin', 'member'
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_read_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(group_id, user_id)
);

-- 7. Khôi phục cột group_id (Chuẩn UUID)
ALTER TABLE public.messages 
ADD COLUMN group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE;

ALTER TABLE public.appointments 
ADD COLUMN group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE;

-- 8. Tạo hàm helper (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION public.is_member_of_group(_group_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 
    FROM public.group_members 
    WHERE group_id = _group_id 
    AND user_id = auth.uid()
  );
END;
$$;
GRANT EXECUTE ON FUNCTION public.is_member_of_group(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_member_of_group(uuid) TO service_role;

-- 9. Bật lại RLS
ALTER TABLE public.groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.group_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.appointments ENABLE ROW LEVEL SECURITY;

-- 10. Thiết lập Policies Mới (Đã kiểm tra kỹ kiểu dữ liệu)

-- === GROUPS ===
CREATE POLICY "groups_insert_policy" ON public.groups FOR INSERT
WITH CHECK (auth.uid() = created_by); -- UUID = UUID

CREATE POLICY "groups_select_policy" ON public.groups FOR SELECT
USING (
    created_by = auth.uid() 
    OR 
    EXISTS (SELECT 1 FROM public.group_members WHERE group_id = id AND user_id = auth.uid())
);

CREATE POLICY "groups_update_policy" ON public.groups FOR UPDATE
USING (
    created_by = auth.uid() 
    OR 
    EXISTS (SELECT 1 FROM public.group_members WHERE group_id = id AND user_id = auth.uid() AND role = 'admin')
);

CREATE POLICY "groups_delete_policy" ON public.groups FOR DELETE
USING (auth.uid() = created_by);

-- === GROUP MEMBERS ===
CREATE POLICY "members_select_policy" ON public.group_members FOR SELECT
USING (
    user_id = auth.uid() -- UUID = UUID
    OR
    EXISTS (
        SELECT 1 FROM public.group_members gm 
        WHERE gm.group_id = group_members.group_id AND gm.user_id = auth.uid()
    )
    OR
    EXISTS (
        SELECT 1 FROM public.groups g
        WHERE g.id = group_members.group_id AND g.created_by = auth.uid()
    )
);

CREATE POLICY "members_insert_policy" ON public.group_members FOR INSERT
WITH CHECK (
    user_id = auth.uid()
    OR
    EXISTS (
        SELECT 1 FROM public.groups 
        WHERE id = group_id AND created_by = auth.uid()
    )
    OR
    EXISTS (
        SELECT 1 FROM public.group_members 
        WHERE group_id = group_members.group_id 
        AND user_id = auth.uid() 
        AND role = 'admin'
    )
);

CREATE POLICY "members_delete_policy" ON public.group_members FOR DELETE
USING (
    user_id = auth.uid()
    OR
    EXISTS (
        SELECT 1 FROM public.groups 
        WHERE id = group_id AND created_by = auth.uid()
    )
    OR
    EXISTS (
        SELECT 1 FROM public.group_members 
        WHERE group_id = group_members.group_id 
        AND user_id = auth.uid() 
        AND role = 'admin'
    )
);

-- === MESSAGES ===
DROP POLICY IF EXISTS "Users can see their own messages and group messages." ON public.messages;
CREATE POLICY "Users can see their own messages and group messages." ON public.messages
  FOR SELECT USING (
    auth.uid() = sender_id 
    OR auth.uid() = receiver_id 
    OR (
      group_id IS NOT NULL AND public.is_member_of_group(group_id)
    )
  );

COMMIT;

NOTIFY pgrst, 'reload schema';
